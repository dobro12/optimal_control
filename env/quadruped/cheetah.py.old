from pybullet_utils import bullet_client
import pybullet as p1
import pybullet_data

from scipy.spatial.transform import Rotation as R
from qpsolvers import solve_qp
from copy import deepcopy
from math import erf
import numpy as np
import random
import time
import copy


def x_rot(t):
  rot = [[1.0,       0.0,        0.0],
          [0.0, np.cos(t), -np.sin(t)],
          [0.0, np.sin(t), np.cos(t)]]
  return np.array(rot)
def y_rot(t):
  rot = [[np.cos(t), 0.0, np.sin(t)],
          [      0.0, 1.0,       0.0],
        [-np.sin(t), 0.0, np.cos(t)]]
  return np.array(rot)
def z_rot(t):
  rot = [[np.cos(t), -np.sin(t), 0.0],
          [np.sin(t),  np.cos(t), 0.0],
          [      0.0,        0.0, 1.0]]
  return np.array(rot)

def x_rot_dot(t):
  rot = [[0.0,       0.0,        0.0],
          [0.0, -np.sin(t), -np.cos(t)],
          [0.0, np.cos(t), -np.sin(t)]]
  return np.array(rot)
def y_rot_dot(t):
  rot = [[-np.sin(t), 0.0, np.cos(t)],
          [      0.0, 0.0,       0.0],
        [-np.cos(t), 0.0, -np.sin(t)]]
  return np.array(rot)
def z_rot_dot(t):
  rot = [[-np.sin(t), -np.cos(t), 0.0],
          [np.cos(t),  -np.sin(t), 0.0],
          [      0.0,        0.0, 0.0]]
  return np.array(rot)

def diag_mat(diag):
  mat = np.eye(len(diag))
  for i in range(len(diag)):
    mat[i,i] = diag[i]
  return mat


class Cheetah(object):
  def __init__( self, pybullet_client, time_step, useFixedBase=True):
    # set elementary variable
    self.pybullet_client = pybullet_client
    self.time_step = time_step
    self.torque_max = 1000.0
    self.torque_min = -self.torque_max
    self.max_force = np.inf #1000.0
    self.num_leg = 4

    # init value
    self.init_base_pos = [0.0, 0.0, 0.25]
    self.init_base_orn = self.pybullet_client.getQuaternionFromEuler([0, 0, 0])
    self.init_joint_state = [-0.1, -0.7, 1.5]*self.num_leg
    for joint_idx in range(len(self.init_joint_state)):
      if int(joint_idx/3)%2 != 0 and joint_idx%3 == 0:
        self.init_joint_state[joint_idx] = -self.init_joint_state[joint_idx]

    # load model
    self.sim_model = self.pybullet_client.loadURDF(
        "mini_cheetah/mini_cheetah.urdf", 
        self.init_base_pos,
        self.init_base_orn,
        globalScaling=1.0,
        useFixedBase=useFixedBase,
        flags=self.pybullet_client.URDF_MAINTAIN_LINK_ORDER)

    # joint info
    self.joint_list = []
    self.joint_info_list = []
    for j in range(self.pybullet_client.getNumJoints(self.sim_model)): #12개
      joint_info = self.pybullet_client.getJointInfo(self.sim_model, j)
      if joint_info[2] == 0: #type of joint
        self.joint_list.append(j)
      self.joint_info_list.append(joint_info)

    # motor init
    for j in self.joint_list:
      self.pybullet_client.setJointMotorControl2(self.sim_model, j, self.pybullet_client.VELOCITY_CONTROL, force=0)

    #geometry
    #FR, FL, HR, HL 순서
    self.abduct_org_list =  np.array([[0.19, -0.049, 0.0],  [0.19, 0.049, 0.0], [-0.19, -0.049, 0.0], [-0.19, 0.049, 0.0]])
    self.thigh_org_list =   np.array([[0.0, -0.062, 0.0],   [0.0, 0.062, 0.0],  [0.0, -0.062, 0.0],   [0.0, 0.062, 0.0]])
    self.knee_org_list =    np.array([[0.0, 0.0, -0.209],   [0.0, 0.0, -0.209], [0.0, 0.0, -0.209],   [0.0, 0.0, -0.209]])
    self.foot_org_list =    np.array([[0.0, 0.0, -0.18],    [0.0, 0.0, -0.18],  [0.0, 0.0, -0.18],    [0.0, 0.0, -0.18]])
    #joint axis
    self.abduct_axis_list = np.array([[1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 0.0, 0.0]])
    self.thigh_axis_list = np.array([[0.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, -1.0, 0.0]])
    self.knee_axis_list = np.array([[0.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, -1.0, 0.0]])

    # physics parameter
    self.inertia = [[0.011253, 0, 0], [0, 0.036203, 0], [0, 0, 0.042673]]
    self.leg_mass = 0.54 + 0.634 + 0.064 + 0.15
    self.feet_mass = self.leg_mass*0.24
    #self.feet_mass = self.leg_mass*0.1
    #self.mass = 0.5*(3.3 + 4*self.leg_mass)
    self.mass = 1.0*(3.3 + 4*self.leg_mass)
    self.gravity = np.array([0, 0, -9.8])
    self.base_com_pos = np.array([1.0e-3, 0.0, 0.0])

    # for gait scheduler
    # trot
    self.t_scale = 1.0
    self.contact_rate = 0.9
    self.phi_offset_list = np.array([0.25, 0.75, 0.75, 0.25]) - 0.75
    '''
    # zigzag
    self.t_scale = 2.0
    self.contact_rate = 0.8
    self.phi_offset_list = np.array([0.5, 0.0, 0.75, 0.25]) - 1.0
    '''
    self.phi_list = deepcopy(self.phi_offset_list)
    self.pre_phi_list = deepcopy(self.phi_list)
    self.des_com_vel = np.array([0.4, 0, 0])

    # weighting factor
    temp_std = 0.3
    self.c_std1 = temp_std
    self.c_std2 = temp_std
    self.s_std1 = temp_std
    self.s_std2 = temp_std

    # for qp solver
    self.alpha = 1e-5
    self.friction_coef = 0.9
    self.gr_norm_vec = np.array([0, 0, 1.0])
    self.gr_tangent_vec1 = np.array([1.0, 0, 0])
    self.gr_tangent_vec2 = np.array([0, 1.0, 0])

    # for balance controller
    self.desired_height = 0.3
    '''
    self.K_pp = np.eye(3)*1000
    self.K_dp = np.eye(3)*30
    self.K_pw = np.eye(3)*4000
    self.K_dw = np.eye(3)*200
    '''
    self.K_pp = np.eye(3)*500
    self.K_dp = np.eye(3)*20
    self.K_pw = np.eye(3)*4000
    self.K_dw = np.eye(3)*200

    # for swing leg trajectory
    t_f = (1 - self.contact_rate)*0.5
    self.time_matrix = np.array([[0, 0, pow(t_f, 3), 3*pow(t_f, 2)],
                                [0, 0, pow(t_f, 2), 2*pow(t_f, 1)],
                                [0, 1, t_f, 1],
                                [1, 0, 1, 0]])
    self.inv_time_matrix = np.linalg.inv(self.time_matrix)
    self.cubic_param_list = [None]*self.num_leg
    self.t_f = t_f
    '''
    self.K_ps = np.eye(3) * 5000.0
    self.K_ds = np.eye(3) * 10
    '''
    '''
    self.K_ps = np.eye(3) * 1000.0
    self.K_ds = np.eye(3) * 1.0
    '''
    '''
    self.K_ps = np.eye(3) * 50.0
    self.K_ds = np.eye(3) * 0.1
    '''
    #'''
    self.K_ps = np.eye(3) * 500.0
    self.K_ds = np.eye(3) * 0.01
    #'''


  def get_torque_from_force(self, force_list):
    base_org, base_orn, base_rot, joint_state, joint_pos_list = self.base_pos, self.base_orn, self.base_rot, self.joint_state, self.joint_pos_list

    torque_list = []
    for leg_idx in range(self.num_leg):
      foot_org = self.foot_org_list[leg_idx]
      knee_org = self.knee_org_list[leg_idx]
      knee_rot = y_rot(-joint_pos_list[2 + leg_idx*3])
      thigh_pos = np.matmul(knee_rot, foot_org) + knee_org

      thigh_org = self.thigh_org_list[leg_idx]
      thigh_rot = y_rot(-joint_pos_list[1 + leg_idx*3])
      abduct_pos = np.matmul(thigh_rot, thigh_pos) + thigh_org

      abduct_org = self.abduct_org_list[leg_idx]
      abduct_rot = x_rot(joint_pos_list[0 + leg_idx*3])
      base_pos = np.matmul(abduct_rot, abduct_pos) + abduct_org

      base_force = np.matmul(np.transpose(base_rot),-force_list[leg_idx])
      abduct_torque = np.dot(np.cross(base_pos - abduct_org, base_force), self.abduct_axis_list[leg_idx])
      abduct_force = np.matmul(np.transpose(abduct_rot), base_force)
      thigh_torque = np.dot(np.cross(abduct_pos - thigh_org, abduct_force), self.thigh_axis_list[leg_idx])
      thigh_force = np.matmul(np.transpose(thigh_rot), abduct_force)
      knee_torque = np.dot(np.cross(thigh_pos - knee_org, thigh_force), self.thigh_axis_list[leg_idx])
      torque_list += [abduct_torque, thigh_torque, knee_torque]
    return torque_list

  def get_torque_from_base_force(self, base_force, leg_idx):
    foot_org = self.foot_org_list[leg_idx]
    knee_org = self.knee_org_list[leg_idx]
    knee_rot = y_rot(-self.joint_pos_list[2 + leg_idx*3])
    thigh_pos = np.matmul(knee_rot, foot_org) + knee_org

    thigh_org = self.thigh_org_list[leg_idx]
    thigh_rot = y_rot(-self.joint_pos_list[1 + leg_idx*3])
    abduct_pos = np.matmul(thigh_rot, thigh_pos) + thigh_org

    abduct_org = self.abduct_org_list[leg_idx]
    abduct_rot = x_rot(self.joint_pos_list[0 + leg_idx*3])
    base_pos = np.matmul(abduct_rot, abduct_pos) + abduct_org

    abduct_torque = np.dot(np.cross(base_pos - abduct_org, base_force), self.abduct_axis_list[leg_idx])
    abduct_force = np.matmul(np.transpose(abduct_rot), base_force)
    thigh_torque = np.dot(np.cross(abduct_pos - thigh_org, abduct_force), self.thigh_axis_list[leg_idx])
    thigh_force = np.matmul(np.transpose(thigh_rot), abduct_force)
    knee_torque = np.dot(np.cross(thigh_pos - knee_org, thigh_force), self.thigh_axis_list[leg_idx])
    torque_list = [abduct_torque, thigh_torque, knee_torque]
    return torque_list

  def get_Jacobian(self, leg_idx, leg_state):
    l_1 = abs(self.knee_org_list[leg_idx][2])
    l_2 = abs(self.foot_org_list[leg_idx][2])
    a_3 = self.thigh_org_list[leg_idx][1]
    c_1 = np.cos(leg_state[0])
    c_2 = np.cos(leg_state[1])
    c_23 = np.cos(leg_state[1] + leg_state[2])
    s_1 = np.sin(leg_state[0])
    s_2 = np.sin(leg_state[1])
    s_23 = np.sin(leg_state[1] + leg_state[2])
    Jacobian = np.array([[0                                     , l_2*c_23 + l_1*c_2          , l_2*c_23      ],
                        [-a_3*s_1 + l_2*c_1*c_23 + l_1*c_1*c_2  , -l_2*s_1*s_23 - l_1*s_1*s_2 , -l_2*s_1*s_23 ],
                        [a_3*c_1 + l_2*s_1*c_23 + l_1*s_1*c_2   , l_2*c_1*s_23 + l_1*c_1*s_2  , l_2*c_1*s_23  ]])
    return Jacobian

  def get_J_dot(self, leg_idx, leg_state):
    l_1 = abs(self.knee_org_list[leg_idx][2])
    l_2 = abs(self.foot_org_list[leg_idx][2])
    a_3 = self.thigh_org_list[leg_idx][1]
    c_1 = np.cos(leg_state[0])
    c_2 = np.cos(leg_state[1])
    c_23 = np.cos(leg_state[1] + leg_state[2])
    s_1 = np.sin(leg_state[0])
    s_2 = np.sin(leg_state[1])
    s_23 = np.sin(leg_state[1] + leg_state[2])
    J1 = np.array([[0                                     , 0                          , 0             ],
                  [-a_3*c_1 - l_2*s_1*c_23 - l_1*s_1*c_2  , -l_2*c_1*s_23 - l_1*c_1*s_2 , -l_2*c_1*s_23 ],
                  [-a_3*s_1 + l_2*c_1*c_23 + l_1*c_1*c_2  , -l_2*s_1*s_23 - l_1*s_1*s_2 , -l_2*s_1*s_23 ]])

    J2 = np.array([[0                           , -l_2*c_23 - l_1*s_2            , -l_2*s_23  ],
                  [-l_2*c_1*s_23 - l_1*c_1*s_2  , -l_2*s_1*c_23 - l_1*s_1*c_2 , -l_2*s_1*c_23 ],
                  [-l_2*s_1*s_23 - l_1*s_1*s_2  , l_2*c_1*c_23 + l_1*c_1*c_2  , l_2*c_1*c_23  ]])

    J3 = np.array([[0           , -l_2*s_23      , -l_2*s_23      ],
                  [-l_2*c_1*s_23 , -l_2*s_1*c_23 , -l_2*s_1*c_23 ],
                  [-l_2*s_1*s_23 , l_2*c_1*c_23  , l_2*c_1*c_23  ]])
    return J1, J2, J3

  def get_cross_mat(self, vector):
    mat = []
    mat.append([0, -vector[2], vector[1]])
    mat.append([vector[2], 0, -vector[0]])
    mat.append([-vector[1], vector[0], 0])
    return np.array(mat)    

  def get_foot_pos_list(self):
    foot_pos_list = []
    base_foot_pos_list = []
    base_foot_vel_list = []
    for leg_idx in range(self.num_leg):
      foot_org = self.foot_org_list[leg_idx]
      knee_org = self.knee_org_list[leg_idx]
      knee_rot = y_rot(-self.joint_pos_list[2 + leg_idx*3])
      thigh_pos = np.matmul(knee_rot, foot_org) + knee_org
      knee_rot_dot = -y_rot_dot(-self.joint_pos_list[2 + leg_idx*3])*self.joint_vel_list[2 + leg_idx*3]
      thigh_vel = np.matmul(knee_rot_dot, foot_org)

      thigh_org = self.thigh_org_list[leg_idx]
      thigh_rot = y_rot(-self.joint_pos_list[1 + leg_idx*3])
      abduct_pos = np.matmul(thigh_rot, thigh_pos) + thigh_org
      thigh_rot_dot = -y_rot_dot(-self.joint_pos_list[1 + leg_idx*3])*self.joint_vel_list[1 + leg_idx*3]
      abduct_vel = np.matmul(knee_rot_dot, thigh_pos) + np.matmul(thigh_rot, thigh_vel)

      abduct_org = self.abduct_org_list[leg_idx]
      abduct_rot = x_rot(self.joint_pos_list[0 + leg_idx*3])
      base_pos = np.matmul(abduct_rot, abduct_pos) + abduct_org
      base_foot_pos_list.append(base_pos)
      abduct_rot_dot = x_rot_dot(self.joint_pos_list[0 + leg_idx*3])*self.joint_vel_list[0 + leg_idx*3] 
      base_vel = np.matmul(abduct_rot_dot, abduct_pos) + np.matmul(abduct_rot, abduct_vel)
      base_foot_vel_list.append(base_vel)

      abs_pos = np.matmul(self.base_rot, base_pos) + self.base_pos
      foot_pos_list.append(abs_pos)
    return np.array(foot_pos_list), np.array(base_foot_pos_list), np.array(base_foot_vel_list)

  def get_state(self):
    self.base_pos, self.base_orn = self.pybullet_client.getBasePositionAndOrientation(self.sim_model)
    self.base_rot = np.reshape(self.pybullet_client.getMatrixFromQuaternion(self.base_orn), (3,3))
    self.base_rpy = self.pybullet_client.getEulerFromQuaternion(self.base_orn)
    self.base_vel, self.base_ang_vel = self.pybullet_client.getBaseVelocity(self.sim_model)
    self.joint_state = self.pybullet_client.getJointStates(self.sim_model, self.joint_list)
    self.joint_pos_list = [state[0] for state in self.joint_state]
    self.joint_vel_list = [state[1] for state in self.joint_state]
    self.body_contact, self.contact_feet_list = self.check_contact()
    self.foot_pos_list, self.base_foot_pos_list, self.base_foot_vel_list = self.get_foot_pos_list()
    self.com_pos = self.base_pos + np.matmul(self.base_rot, self.base_com_pos)

    state = list(self.base_orn)+list(self. base_vel)+list(self.base_ang_vel)+self.joint_pos_list+self.joint_vel_list+self.contact_feet_list
    return np.array(state)

  def get_desired_com_pos(self):
    weight_list = []
    phi_list = np.max([self.phi_list, np.zeros_like(self.phi_list)], axis=0)
    for leg_idx in range(self.num_leg):
      if phi_list[leg_idx] < self.contact_rate:
        #stance 상태
        phi_stance = phi_list[leg_idx]/self.contact_rate
        weight = erf(phi_stance/self.c_std1) + erf((1 - phi_stance)/self.c_std2)
      else:
        #swing 상태
        phi_swing = (phi_list[leg_idx] - self.contact_rate)/(1 - self.contact_rate)
        weight = erf(1/self.s_std1) + erf(1/self.s_std2) - erf(phi_swing/self.s_std1) - erf((1 - phi_swing)/self.s_std2)
      weight = weight/2
      weight_list.append(weight)

    support_polygon = []
    for leg_idx in range(self.num_leg):
      if leg_idx == 0 or leg_idx == 3:
        next_idx, pre_idx = [1, 2]
      else:
        next_idx, pre_idx = [3, 0]
      weight = weight_list[leg_idx]
      next_w = weight_list[next_idx]
      pre_w = weight_list[pre_idx]
      virtual_point1 = weight*self.foot_pos_list[leg_idx] + (1 - weight)*self.foot_pos_list[next_idx]
      virtual_point2 = weight*self.foot_pos_list[leg_idx] + (1 - weight)*self.foot_pos_list[pre_idx]
      polygon_point = weight*self.foot_pos_list[leg_idx] + next_w*virtual_point1 + pre_w*virtual_point2
      polygon_point /= (weight + next_w + pre_w)
      support_polygon.append(polygon_point)
    desired_com_pos = np.mean(support_polygon, axis=0)
    return desired_com_pos

  def balance_controller(self, com_pos, des_rot, des_com_pos, des_com_vel, des_ang_vel):
    #################
    ## get A and b ##
    center_mat_list = []
    for leg_idx in range(self.num_leg):
      center_pos = self.foot_pos_list[leg_idx] - com_pos
      center_mat = self.get_cross_mat(center_pos)
      center_mat_list.append(center_mat)
    center_mat = np.concatenate(center_mat_list, axis=1)
    A_mat = np.concatenate([np.eye(3),np.eye(3),np.eye(3),np.eye(3)], axis=1)
    A_mat = np.concatenate([A_mat, center_mat], axis=0)

    log_RdRT = R.from_matrix(np.matmul(des_rot, self.base_rot.T))
    log_RdRT = log_RdRT.as_rotvec()

    des_com_acc = np.matmul(self.K_pp, des_com_pos - com_pos) + np.matmul(self.K_dp, des_com_vel - self.base_vel)
    des_ang_acc = np.matmul(self.K_pw, log_RdRT) + np.matmul(self.K_dw, des_ang_vel - self.base_ang_vel)
    I_G = np.matmul(np.matmul(self.base_rot, self.inertia), self.base_rot.T)
    des_b = np.concatenate([self.mass * (des_com_acc - self.gravity), np.matmul(I_G, des_ang_acc)])
    ## get A and b ##
    #################

    ###################
    ## for qp solver ##
    f_max_list = np.array(self.phi_list < self.contact_rate, dtype=np.float)*1000.0 + 1e-2
    c_mat_list = []
    d_vector = []
    for leg_idx in range(self.num_leg):
      c_mat = []
      c_mat.append(-self.friction_coef*self.gr_norm_vec + self.gr_tangent_vec1)
      c_mat.append(-self.friction_coef*self.gr_norm_vec + self.gr_tangent_vec2)
      c_mat.append(-self.friction_coef*self.gr_norm_vec - self.gr_tangent_vec1)
      c_mat.append(-self.friction_coef*self.gr_norm_vec - self.gr_tangent_vec2)
      c_mat.append(self.gr_norm_vec)
      c_mat = np.array(c_mat)
      zero_mat = np.zeros_like(c_mat)
      temp_mat = []
      for temp_idx in range(4):
        if temp_idx == leg_idx:
          temp_mat.append(c_mat)
        else:
          temp_mat.append(zero_mat)
      c_mat_list.append(np.concatenate(temp_mat, axis=1))
      f_max = f_max_list[leg_idx]
      d_vector.append(np.array([0.0, 0.0, 0.0, 0.0, f_max]))
    c_mat = np.concatenate(c_mat_list, axis=0)
    d_vector = np.concatenate(d_vector, axis=0)

    p_mat = np.matmul(A_mat.T, A_mat) + np.eye(12)*self.alpha
    q_vector = -np.matmul(A_mat.T, des_b)
    des_force_list = solve_qp(p_mat, q_vector, c_mat, d_vector, None, None)
    ## for qp solver ##
    ###################

    des_force_list = des_force_list.reshape((4,3))
    return des_force_list

  '''
  def swing_leg_controller(self, leg_idx, des_com_vel):
    base_foot_pos = self.base_foot_pos_list[leg_idx]
    base_foot_vel = self.base_foot_vel_list[leg_idx]
    joint_pos = self.joint_pos_list[3*leg_idx:3*(leg_idx+1)]
    joint_vel = self.joint_vel_list[3*leg_idx:3*(leg_idx+1)]

    if self.pre_phi_list[leg_idx]  < self.contact_rate:
      via_point = deepcopy(self.abduct_org_list[leg_idx] + self.thigh_org_list[leg_idx] + (2*(leg_idx%2)-1)*np.array([0.0, 0.05, 0.0]))
      via_point[2] = -0.15
      via_point[0] += des_com_vel[0]*self.t_f*1
      via_point2 = deepcopy(self.abduct_org_list[leg_idx] + self.thigh_org_list[leg_idx] + (2*(leg_idx%2)-1)*np.array([0.0, 0.05, 0.0]))
      via_point2[2] = base_foot_pos[2]
      via_point2[0] += des_com_vel[0]*self.t_f*2
      x_list = np.array([base_foot_pos, base_foot_vel, via_point, np.zeros(3)])
      x_list = x_list.T
      cubic_param1 = np.matmul(x_list, self.inv_time_matrix)
      x_list = np.array([via_point, np.zeros(3), via_point2, np.zeros(3)])
      x_list = x_list.T
      cubic_param2 = np.matmul(x_list, self.inv_time_matrix)
      self.cubic_param_list[leg_idx] = [cubic_param1, cubic_param2]

    if self.phi_list[leg_idx] - self.contact_rate > self.t_f:
      cubic_param = self.cubic_param_list[leg_idx][1]
      phi = self.phi_list[leg_idx] - self.contact_rate - self.t_f
    else:
      cubic_param = self.cubic_param_list[leg_idx][0]
      phi = self.phi_list[leg_idx] - self.contact_rate
    desired_base_foot_pos = np.ravel(np.matmul(cubic_param, [pow(phi, 3), pow(phi, 2), phi, 1]))
    desired_base_foot_vel = np.ravel(np.matmul(cubic_param, [3*pow(phi, 2), 2*phi, 1, 0]))
    desired_base_foot_acc = np.ravel(np.matmul(cubic_param, [6*phi, 2, 0, 0]))

    #################
    ## feedforward ##
    ff_torque_list = np.zeros(3)
    mass = self.feet_mass
    g = -self.gravity[1]
    Jacobian = self.get_Jacobian(leg_idx, joint_pos)
    J1_dot, J2_dot, J3_dot = self.get_J_dot(leg_idx, joint_pos)
    J_dot = J1_dot*joint_vel[0] + J2_dot*joint_vel[1] + J3_dot*joint_vel[2]
    round_J = np.zeros((3,3))
    round_J[:,0] = np.matmul(J1_dot, joint_vel)
    round_J[:,1] = np.matmul(J2_dot, joint_vel)
    round_J[:,2] = np.matmul(J3_dot, joint_vel)
    #M(theta)
    ff_torque_list += np.matmul(Jacobian.T, desired_base_foot_acc - np.matmul(J_dot, joint_vel))
    #C(theta, theta_dot)
    C_mat = np.matmul(J_dot.T, Jacobian) + np.matmul(Jacobian.T, J_dot) - np.matmul(round_J.T, Jacobian)
    ff_torque_list += np.matmul(C_mat, joint_vel)
    #G(theta)
    G_mat = np.matmul(self.base_rot.T, -self.gravity)
    G_mat = np.matmul(Jacobian.T, G_mat)
    ff_torque_list += G_mat
    ## feedforward ##
    #################

    differ_base_foot_pos = desired_base_foot_pos - base_foot_pos
    differ_base_foot_vel = desired_base_foot_vel - base_foot_vel
    force_list = np.matmul(self.K_ps, differ_base_foot_pos) + np.matmul(self.K_ds, differ_base_foot_vel)
    swing_torque_list = np.matmul(Jacobian.T, force_list) + mass*ff_torque_list
    return swing_torque_list
  '''
  #def swing_leg_controller(self, leg_idx, target_vel):
  def swing_leg_controller(self, leg_idx, swing_trajectory, elapsed_t):
    base_foot_pos = self.base_foot_pos_list[leg_idx]
    base_foot_vel = self.base_foot_vel_list[leg_idx]
    joint_pos = self.joint_pos_list[3*leg_idx:3*(leg_idx+1)]
    joint_vel = self.joint_vel_list[3*leg_idx:3*(leg_idx+1)]

    '''
    #desired_base_foot_pos = self.abduct_org_list[leg_idx] + self.thigh_org_list[leg_idx] + np.array([0, 0, 0.05-self.base_pos[2]]) + (2*(leg_idx%2)-1)*np.array([0.0, 0.1, 0.0])
    desired_base_foot_pos = self.abduct_org_list[leg_idx] + self.thigh_org_list[leg_idx] + np.array([0.0, 0.0, -0.2])\
                             + (2*(leg_idx%2)-1)*np.array([0.0, 0.1, 0.0]) + target_vel
    desired_base_foot_vel = np.zeros(3)
    desired_base_foot_acc = np.zeros(3)
    '''
    desired_base_foot_pos = np.zeros(3)
    desired_base_foot_vel = np.zeros(3)
    desired_base_foot_acc = np.zeros(3)
    p0, p_ref, ts, te = swing_trajectory
    z0, zc = p0[2], p_ref[2]
    desired_base_foot_pos = (p_ref - p0)*(elapsed_t - ts)/(te - ts) + p0
    desired_base_foot_pos[2] = (z0 - zc)*(((2*elapsed_t - ts - te)/(te - ts))**2) + zc
    desired_base_foot_vel = (p_ref - p0)/(te - ts)
    desired_base_foot_vel[2] = 4*(z0 - zc)*(2*elapsed_t - ts - te)/((te - ts)**2)
    desired_base_foot_acc[2] = 8*(z0 - zc)/((te - ts)**2)

    #################
    ## feedforward ##
    ff_torque_list = np.zeros(3)
    mass = self.feet_mass
    g = -self.gravity[1]
    Jacobian = self.get_Jacobian(leg_idx, joint_pos)
    J1_dot, J2_dot, J3_dot = self.get_J_dot(leg_idx, joint_pos)
    J_dot = J1_dot*joint_vel[0] + J2_dot*joint_vel[1] + J3_dot*joint_vel[2]
    round_J = np.zeros((3,3))
    round_J[:,0] = np.matmul(J1_dot, joint_vel)
    round_J[:,1] = np.matmul(J2_dot, joint_vel)
    round_J[:,2] = np.matmul(J3_dot, joint_vel)
    #M(theta)
    ff_torque_list += np.matmul(Jacobian.T, desired_base_foot_acc - np.matmul(J_dot, joint_vel))
    #C(theta, theta_dot)
    C_mat = np.matmul(J_dot.T, Jacobian) + np.matmul(Jacobian.T, J_dot) - np.matmul(round_J.T, Jacobian)
    ff_torque_list += np.matmul(C_mat, joint_vel)
    #G(theta)
    G_mat = np.matmul(self.base_rot.T, -self.gravity)
    G_mat = np.matmul(Jacobian.T, G_mat)
    ff_torque_list += G_mat
    ## feedforward ##
    #################

    differ_base_foot_pos = desired_base_foot_pos - base_foot_pos
    differ_base_foot_vel = desired_base_foot_vel - base_foot_vel
    force_list = np.matmul(self.K_ps, differ_base_foot_pos) + np.matmul(self.K_ds, differ_base_foot_vel)
    force_list = np.clip(force_list, -self.max_force, self.max_force)
    swing_torque_list = np.matmul(Jacobian.T, force_list) + mass*ff_torque_list
    return swing_torque_list

  def get_mod(self, value_list):
    if type(value_list) == float:
      if value_list >= 0:
        value_list = np.mod(value_list, 1)
    else:
      for idx, value in enumerate(value_list):
        if value < 0:
          continue
        value_list[idx] = np.mod(value, 1)
    return value_list

  '''
  def get_torque_list(self, inputs, elapsed_t):
    # get states
    state = self.get_state()

    # update phi_list
    is_phi_updated = True
    for leg_idx in range(len(self.phi_list)):
      if self.pre_phi_list[leg_idx] > self.phi_list[leg_idx]:
        if self.contact_feet_list[leg_idx] != 1:
          is_phi_updated = False
    if is_phi_updated:
      self.pre_phi_list = deepcopy(self.phi_list)
      self.phi_list = self.get_mod(self.phi_offset_list + elapsed_t/self.t_scale)

    # get desired center pos
    des_com_pos = self.get_desired_com_pos()
    des_com_pos[2] = self.desired_height

    # set another desired value
    des_com_vel = self.des_com_vel
    des_ang_vel = np.zeros(3)
    des_rot = np.eye(3)

    # balance controller
    com_pos = self.base_pos + np.matmul(self.base_rot, self.base_com_pos)
    des_force_list = self.balance_controller(com_pos, des_rot, des_com_pos, des_com_vel, des_ang_vel)
    torque_list = self.get_torque_from_force(des_force_list)

    # swing leg controller
    for swing_leg_idx in range(self.num_leg):
      if self.phi_list[swing_leg_idx] < self.contact_rate:
        continue
      swing_torque_list = self.swing_leg_controller(swing_leg_idx, des_com_vel)
      torque_list[swing_leg_idx*3:(swing_leg_idx + 1)*3] = swing_torque_list

    return torque_list
  '''
  #def get_torque_list(self, force_list, contact_list, target_vel):
  def get_torque_list(self, force_list, contact_list, swing_trajectory_list, elapsed_t):
    force_list = np.clip(force_list, -self.max_force, self.max_force)
    force_list[:,2] = np.clip(force_list[:,2], 0, self.max_force)
    torque_list = self.get_torque_from_force(force_list)
    for swing_leg_idx in range(self.num_leg):
      if contact_list[swing_leg_idx] == 1.0:
        continue
      #swing_torque_list = self.swing_leg_controller(swing_leg_idx, target_vel)
      _, _, ts, te = swing_trajectory_list[swing_leg_idx]
      if self.contact_feet_list[swing_leg_idx] == 1 and elapsed_t > (ts + te)/2.0:
        torque_list[swing_leg_idx*3:(swing_leg_idx + 1)*3] = np.zeros(3)
      else:
        swing_torque_list = self.swing_leg_controller(swing_leg_idx, swing_trajectory_list[swing_leg_idx], elapsed_t)
        torque_list[swing_leg_idx*3:(swing_leg_idx + 1)*3] = swing_torque_list
    return torque_list


  def reset_pose(self):
    self.pybullet_client.resetBasePositionAndOrientation(self.sim_model, self.init_base_pos, self.init_base_orn)
    self.pybullet_client.resetBaseVelocity(self.sim_model, np.zeros(3), np.zeros(3))
    for i,j in enumerate(self.joint_list):
      self.pybullet_client.resetJointState(self.sim_model, j, self.init_joint_state[i], 0.0) #velocity = 0.0 으로 setting

  def apply_torque(self, torque_list):
    for i,j in enumerate(self.joint_list):
      torque = np.clip(torque_list[i], self.torque_min, self.torque_max)
      self.pybullet_client.setJointMotorControl2(self.sim_model, j, self.pybullet_client.TORQUE_CONTROL, force=torque)

  def check_contact(self):
    pts = self.pybullet_client.getContactPoints(self.sim_model)
    contact_feet_list = [0 for i in range(4)]
    # 2:FR, 5:FL, 8:RR, 11:RL
    feet_list = [2,6,10,14]
    feet_list2 = [3,7,11,15]
    body_contact = 0 #False
    for p in pts:
      if p[1] == self.sim_model:
        part = p[3]
      elif p[2] == self.sim_model:
        part = p[4]
      if not (part in feet_list or part in feet_list2):
        body_contact = 1 #True
      else:
        contact_feet_list[int((part-2)/4)] = 1
    return body_contact, contact_feet_list

  def get_base_pos(self):
    base_pos, base_orn = self.pybullet_client.getBasePositionAndOrientation(self.sim_model)
    return base_pos

  def reset(self):
    self.reset_pose()
    self.phi_list = deepcopy(self.phi_offset_list)
    self.pre_phi_list = deepcopy(self.phi_list)
    state = self.get_state()
    return state
